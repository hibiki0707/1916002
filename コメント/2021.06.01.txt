namespace（名前空間）

プログラムがでかくなったり、ライブラリ化したり
したときに、型の名前が重複することがある。

なので、カテゴリごとに「名前空間」というものを作って
その中に入れてしまう。そうすると、その名前空間名を
介してしかアクセスできなくなる。

定義
namespace 名前｛
	この中に型だの関数だの変数だのを定義する
｝// セミコロン；必要ない

例えば、ある名前空間の中にクラスを指定するときは
「翻訳単位」というのは、cpp→objへ変換する単位の事
つまりcpp1個につき、1回しか読み込まれませんよという意味になり
これもインクルードガードとなります。

ちなみに#pragmaというのは、プリプロセッサの中でも
かなり特殊で、#progmaの後に続く「指定」によって意味が全く変わる。

例えば
#progma once // そのファイルは1回しか読まれません
#progma comment(lib,ライブラリファイル名） // はライブラリのリンクします
#progma pack(1) // メモリ区切りを1バイト単位とする


入り組んだプログラムを書く際には、原則として
ヘッダファイルに#includeを書かずに
プロトタイプ宣言で何とかする。
cpp側で#includeで、その必要なヘッダをインクルードすればいい

じゃないと、循環参照が起きたり、無駄にプログラムサイズがでかくなったりする。



名前空間名：：クラス名
のように指定する。

頭に甘え空間名が付くことで、同じ名前のクラス名が別
ライブラリにあっても区別をつけることができる。

だけでも、逆に言うと、名前空間名を付けないと使えない。


constexprとconstについて
constは定数だけども、
コンパイル時に決まっておく必要はない
const int a=GetCurrentNumber();
定数とはいえ、意味合い的には「一度入れたら変更不可」
という意味で厳密な「定数」とは違う
constexpr int b=GetCurrentNumber(); //×
なんで×かというと、コンパイル時に値が確定しない

なので、変更不可ではあるが、実行時にならないと
値が分からないものにはconstを使用し、コンパイル時に
値が確定する場合にはconstexprを使用しましょう。

つまり、#define FMAX 1000000.0fみたいにな使い方をされている部分は、constexprに直しましょう。

ちなみに、C++プログラミングでは#defineによる定数や
マクロは嫌われている←副作用がスゴイから。
これは、状況にかかわらず回答無用で変換するので危ないため