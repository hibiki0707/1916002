シングルトーンパターン
クラスや構造体の「型」じたいは、メモリは食わない。
「型」を宣言したり、newとかmallocとかをしたときにメモリを食う。
なにかしらの用途に使うために、その方に応じたメモリ領域→オブジェクト（実体）

int a;　// 実態がある（int型メモリを確保している）
struct Test; // 単なる型
Test test;　// Testのサイズでメモリが確保され、それをtestという名前に割り当てている
Test* pTest = new Test();　// Testで動的にメモリが確保されそれを指し示す
ポインタ「型」が宣言され、アドレスが代入される。
ここでは、new TestでTestのサイズ分のメモリがヒープに確保され、
さらに、それを指し示すためのポインタ変数8バイト分もメモリに確保され、
そのポインタ変数が、newの内容を指し示している・

シングルトンパターンの定義：アプリケーション中にそのクラスのオブジェクトが
ただひとつしか存在しない事を「保証する」

C++などではこの「保証する」という概念？感覚？が割と重要。

メンバ変数の宣伝で、
int GetLife()const;
最後にconstをつけるには、
メンバ変数などの内部的な値がこの関数で変わらないよ」よいう保証になる。

static変数みたいなものだけど、シングルトンは変数ではなく、クラスに
対してそれを保証するパターン。つまり、2つ以上存在できない仕組みを作る。

シングルトンパターンは、〇〇マネージャとか、全体共通して使うクラスなど
に使用されます。
シングルトンパターンは1つしかないけど、きちんとオブジェクト化されてる
のが特徴。
これによりシングルトンの内部の変数が「お行儀のいい」グローバル変数として
機能。

全体共通して使うクラスには、singletonだけでなく、ヘルパークラスなど
もある（便利な関数集など）けど、ヘルパーの方は自分自身をオブジェクト化
しない。内部の関数がすべてstaticになってることが多い。

シングルトンクラスは、コンストラクタをprivateにするだけでは不十分です。
コピーコンストラクタや、代入が生きていると、2つないはずの
シングルトンクラスオブジェクトが複数存在できしまう。

コピーも代入も禁止。


所謂クソコードと呼ばれるものがある

関数分けされていない、意味不明の名前がついている
ネストが深いとか・・・いろいろある。

この中でも「マジックナンバー」というクソコード
「数値が直接書いてある」←クソコード

↓こういうのか
sin(60.0f*3.14159265358979f/180.0f);

↓クソクソクソクソコード
switch(value){
	case 0: // スライム
	case 1; // スケルトン
	case 2; // ドラゴン
	case 4; // 魔法使い
	case 16; // 魔王
}

何でこういうのがダメなのか
①まず所見の人にわかりづらい
②数字の意味を変えたくても変えられなくなる
　　　1か所ならまだましだが、これが数か所あると
　　　収拾がつかなくなる→バグの温床になる
※コメントつけりゃいいだろってのは、②を引き起こす
可能性があるので×

値の意味を統一するため「定数」を使う
昔のC言語の時代は定数といえば#defineだった

#define SLIME_NO 1
#define SKELTON_NO 2
switch(value){
	case SLIME_NO; // スライム
	case SKELTON_NO; // スケルトン
}

π = 3.14159265358979f;
π = 3.14f;
π = 3

sin(60.0f*3.14159265358979f/180.0f);
→
#define PI 3.14159265358979f
sin(60.0f*PI/180.0f);

#define DEG_TO_RAD(DEG) DEG*PI/180.0f
sin(DEG_TO_RAD(60.0f));

ところが、これはちょっと古い書き方です。
#define自体がC++の時代では、嫌われもんです。
なぜなら、副作用が強いのと、いろいろとユルユルだから

[#defineを使わずconstを使おう」1998年
const float PI = 3.10159265358979f;

「コンパイル時に値が確定している定数にはconstexprを使おう」2015年
constexpr float PI=3.14159265358979f;

constexprとconstについて

constは定数ですが、
コンパイル時に決まっておく必要はない
const int a=GetCurrentNumber(); // 〇
定数とは言え、意味合う敵には「一度入れたら変更不可」
という意味で厳密な「定数」とは違う
constexpr int b=GetCurrentNumber(); // ×
なんで×かというと、コンパイル時に値が確定しない

なので、変更不可ではあるが、実行時にならないと
値が分からないものにはconstを使用し、コンパイル時に
値が確定する場合にはconstexprに直す。

ちなみに、C++プログラミングでは#defineによる定数や
マクロは嫌われている←副作用がスゴイ
これは、状況にかかわらず問答無用で変換するので危ないため